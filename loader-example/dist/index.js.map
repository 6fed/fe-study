{
    "version": 3,
    "sources": [
        "webpack:///webpack/bootstrap",
        "webpack:///./article/loader.md",
        "webpack:///./src/index.js"
    ],
    "names": [
        "console",
        "log",
        "md"
    ],
    "mappings": ";;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA,+JAA+J,aAAa,WAAW,kBAAkB,UAAU,kBAAkB,WAAW,kBAAkB,iDAAiD,qDAAqD,qEAAqE,gBAAgB,EAAE,sCAAsC,uPAAuP,oBAAoB,eAAe,2CAA2C,eAAe,OAAO,GAAG,qHAAqH,iBAAiB,8BAA8B,eAAe,kCAAkC,yBAAyB,gBAAgB,uBAAuB,yBAAyB,YAAY,KAAK,8BAA8B,WAAW,gBAAgB,MAAM,UAAU,mGAAmG,8BAA8B,+qBAA+qB,KAAK,sBAAsB,4G;;;;;;;;;;;;ACAthE;AAAA;AAAA;AAAA;AACAA,QAAQC,GAAR,CAAYC,yDAAZ,E",
    "file": "index.js",
    "sourcesContent": [
        " \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n",
        "module.exports = \"<p>Webpack中loader文件处理器是一个CommonJs风格的函数，该函数接收一个 String/Buffer 类型的入参，并返回一个 String/Buffer 类型的返回值。</p>\\n<pre><code class=\\\"language-js\\\">import { getOptions } from &#39;loader-utils&#39;;\\nimport { validateOptions } from &#39;schema-utils&#39;;\\nmodule.exports = function(content, map, meta) {\\n // 获取 options\\n  const options = getOptions(this);\\n  // 检验loader的options是否合法\\n  validateOptions(schema, options, &#39;Demo Loader&#39;);\\n   // 在这里写转换 loader 的逻辑\\n  // ...\\n}</code></pre>\\n<ul>\\n<li>content: 表示源文件字符串或者buffer</li>\\n<li>map: 表示sourcemap对象</li>\\n<li>meta: 表示元数据，辅助对象</li>\\n</ul>\\n<h2 id=\\\"loader-的配置\\\">loader 的配置</h2>\\n<p>方案1:</p>\\n<pre><code class=\\\"language-js\\\">\\n// webpack.config.js\\nmodule.exports = {\\n  ...\\n  module: {\\n    rules: [{\\n      test: /.vue$/,\\n      loader: &#39;vue-loader&#39;\\n    }, {\\n      test: /.scss$/,\\n      // 先经过 sass-loader，然后将结果传入 css-loader，最后再进入 style-loader。\\n      use: [\\n        &#39;style-loader&#39;,//从JS字符串创建样式节点\\n        &#39;css-loader&#39;,// 把  CSS 翻译成 CommonJS\\n        {\\n          loader: &#39;sass-loader&#39;,\\n          options: {\\n            data: &#39;$color: red;&#39;// 把 Sass 编译成 CSS\\n          }\\n        }\\n      ]\\n    }]\\n  }\\n  ...\\n}</code></pre>\\n<p>方法2（右到左地被调用）</p>\\n<pre><code class=\\\"language-js\\\">// module\\nimport a from &#39;raw-loader!../../utils.js&#39;</code></pre>\\n<p>三、loader 的一些开发技巧\\n1、单一任务\\n只做一件事情，做好一件事情。loader 的管道（pipeline）设计正是希望能够将任务拆解并独立成一个个子任务，由多个 loader 分别处理，以此来保证每个 loader 的可复用性。因此我们在开发 loader 前一定要先给 loader 一个准确的功能定位，从通用的角度出发去设计，避免做多余的事。</p>\\n<p>2、无状态\\nloader 应该是不保存状态的。这样的好处一方面是使我们 loader 中的数据流简单清晰，另一方面是保证 loader 具有良好可测性。因此我们的 loader 每次运行都不应该依赖于自身之前的编译结果，也不应该通过除出入参外的其他方式与其他编译模块进行数据交流。当然，这并不代表 loader 必须是一个无任何副作用的纯函数，loader 支持异步，因此是可以在 loader 中有 I/O 操作的。</p>\\n<p>3、尽可能使用缓存\\n在开发时，loader 可能会被不断地执行，合理的缓存能够降低重复编译带来的成本。loader 执行时默认是开启缓存的，这样一来， webpack 在编译过程中执行到判断是否需要重编译 loader 实例的时候，会直接跳过 rebuild 环节，节省不必要重建带来的开销。</p>\\n<p>当且仅当有你的 loader 有其他不稳定的外部依赖（如 I/O 接口依赖）时，可以关闭缓存：</p>\\n<pre><code class=\\\"language-js\\\">this.cacheable&amp;&amp;this.cacheable(false);</code></pre>\\n<p> 这样一来，我们需要的 md-loader，就只做一件事情：将 md 的数据转化成为一个 JSON 字符串。因此，我们可以很简单地实现这样一个 md-loader：</p>\\n\";",
        "import md from \"../article/loader.md\"\nconsole.log(md)"
    ],
    "sourceRoot": ""
}